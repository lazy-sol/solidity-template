{
  "language": "Solidity",
  "sources": {
    "contracts/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22; // require with message (0.4.22), pure/view modifiers (0.4.16), hardhat (0.4.11)\n\n/**\n * @title Role-based Access Control (RBAC)\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @author Basil Gorin\n */\nabstract contract AccessControl {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) private userRoles;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(role), \"access denied\");\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Creates an access control instance, setting the contract owner to have full privileges\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tconstructor(address _owner) internal { // visibility modifier is required to be compilable with 0.6.x\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "contracts/AdapterFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./OwnableToAccessControlAdapter.sol\";\n\n/**\n * @notice Ownable is a contract which is aware of its owner, that is has owner() function\n */\ninterface Ownable {\n\t/**\n\t * @notice Smart contract owner\n\t *\n\t * @return the address of the smart contract owner\n\t */\n\tfunction owner() external returns(address);\n}\n\n/**\n * @title Adapter Factory\n *\n * @notice Helper contract simplifying the deployment of the OwnableToAccessControlAdapter\n *\n * @author Basil Gorin\n */\ncontract AdapterFactory {\n\t/**\n\t * @dev Fired in deployNewOwnableToAccessControlAdapter\n\t *\n\t * @param adapterAddress newly deployed OwnableToAccessControlAdapter address\n\t * @param ownableTargetAddress OZ Ownable target contract address\n\t */\n\tevent NewOwnableToAccessControlAdapterDeployed(address indexed adapterAddress, address indexed ownableTargetAddress);\n\n\t/**\n\t * @notice Deploys new OwnableToAccessControlAdapter bound to the OZ Ownable contract specified.\n\t *      Can be executed only by the OZ Ownable target owner. This owner is expected to transfer\n\t *      the ownership to the newly deployed OwnableToAccessControlAdapter contract address.\n\t *\n\t * @param targetAddress OZ Ownable target address to bind OwnableToAccessControlAdapter to\n\t * @return address of the newly deployed OwnableToAccessControlAdapter contract\n\t */\n\tfunction deployNewOwnableToAccessControlAdapter(address targetAddress) public returns(address) {\n\t\t// verify sender is a target owner\n\t\trequire(Ownable(targetAddress).owner() == msg.sender, \"not an owner\");\n\n\t\t// deploy the OwnableToAccessControlAdapter\n\t\taddress adapterAddress = address(new OwnableToAccessControlAdapter(targetAddress, msg.sender));\n\n\t\t// emit an event\n\t\temit NewOwnableToAccessControlAdapterDeployed(adapterAddress, targetAddress);\n\n\t\t// return address of the newly deployed OwnableToAccessControlAdapter contract\n\t\treturn adapterAddress;\n\t}\n}\n"
    },
    "contracts/OwnableToAccessControlAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2; // breaking changes in .call() (0.5.0), allow .call{}() (0.6.2)\n\nimport \"./AccessControl.sol\";\n\n/**\n * @title OZ Ownable to AccessControl Adapter (short: AccessControl Adapter)\n *\n * @notice Helper contract allowing to change the access model of the already deployed\n *      OpenZeppelin Ownable contract to the AccessControl model\n *\n * @dev Installation Flow\n *      Prerequisite: deployed OZ Ownable contract (target contract) address (target_address)\n *\n *      1. Deploy the AccessControl Adapter bound to the already deployed OZ Ownable contract\n *         (specify the target OZ Ownable contract address in the constructor upon the deployment)\n *\n *            const adapter = await (artifacts.require(\"OwnableToAccessControlAdapter\")).new(target_address);\n *\n *      2. Define what Ownable-restricted public functions on the target contract you'd like to be able\n *         to provide access to through the adapter contract\n *\n *      3. Map every such function with the role required to execute it using `updateAccessRole()` function\n *         For example, to be able to provide an access to the transferOwnership(address) function, you could do\n *\n *            const ROLE_TRANSFER_OWNERSHIP_MANAGER = 0x00010000;\n *            await adapter.updateAccessRole(\"transferOwnership(address)\", ROLE_TRANSFER_OWNERSHIP_MANAGER);\n *\n *      4. Provide the roles to the corresponding operators as you would usually do with AccessControl\n *         For example, if you wish an address 0x00000000000000000000000000000000000Ff1CE to grant an access to the\n *         transferOwnership(address) function on the target, you could do\n *\n *            const operator = \"0x00000000000000000000000000000000000Ff1CE\";\n *            await adapter.updateRole(operator, ROLE_TRANSFER_OWNERSHIP_MANAGER);\n *\n *      5. Transfer the ownership of the target contract to the deployed AccessControl Adapter contract\n *         Note that you can also do steps 2-4 after the step 5\n *\n * @dev Usage Flow\n *      Prerequisite: installed AccessControl Adapter with the access to at least one restricted target contract\n *      function configured\n *\n *      To execute the restricted access function on the target contract via the AccessControl Adapter\n *      1. Use target contract ABI to construct a low-level function call calldata\n *         For example, to construct the transferOwnership() function calldata to transfer the ownership to the\n *         0x00000000000000000000000000000000DEAdc0De address, you could do\n *\n *            const to = \"0x00000000000000000000000000000000DEAdc0De\";\n *            const calldata = target.contract.methods.transferOwnership(to).encodeABI();\n *\n *       2. Execute a low-level function call on the AccessControl Adapter contract using the constructed calldata\n *          For example, to execute the transferOwnership() function (prepared in step 1), you could do\n *\n *            await web3.eth.sendTransaction({\n *                from: operator,\n *                to: adapter.address,\n *                data: calldata,\n *            }\n *\n *        3. It is also ok to add an ether to the transaction by adding a value field to the `sendTransaction` call,\n *           as well as sending plain ether transfer transaction, as long as target contract has payable functions,\n *           and/or has a default payable receiver\n *\n * @author Basil Gorin\n */\ncontract OwnableToAccessControlAdapter is AccessControl {\n\t/**\n\t * @dev Target OZ Ownable contract AccessControl Adapter executes the transactions on\n\t *\n\t * @dev Target contract must transfer its ownership to the AccessControl Adapter\n\t */\n\taddress public target;\n\n\t/**\n\t * @dev Access roles mapping stores the roles required to access the functions on the\n\t *      target contract, guarding it from the unauthorized access\n\t *\n\t * @dev Maps function selector (bytes4) on the target contract to the access role (permission)\n\t *      required to execute the function\n\t */\n\tmapping(bytes4 => uint256) public accessRoles;\n\n\t/**\n\t * @notice Access Roles manager is responsible for assigning the access roles to functions\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying `accessRoles` mapping\n\t */\n\tuint256 public constant ROLE_ACCESS_ROLES_MANAGER = 0x2000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Fired in `updateAccessRole` when the `accessRoles` mapping is updated\n\t *\n\t * @param selector selector of the function which corresponding access role was updated\n\t * @param role effective required role to execute the function defined by the selector\n\t */\n\tevent AccessRoleUpdated(bytes4 selector, uint256 role);\n\n\t/**\n\t * @dev Logs function execution result on the target if the execution completed successfully\n\t *\n\t * @param selector selector of the function which was executed on the target contract\n\t * @param data full calldata payload passed to the target contract (includes the 4-bytes selector)\n\t * @param result execution response from the target contract\n\t */\n\tevent ExecutionComplete(bytes4 selector, bytes data, bytes result);\n\n\t/**\n\t * @dev Deploys an AccessControl Adapter binding it to the target OZ Ownable contract,\n\t *      and setting the ownership of the adapter itself to the deployer\n\t *\n\t * @param _target target OZ Ownable contract address\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tconstructor(address _target, address _owner) public AccessControl(_owner) {\n\t\t// verify the inputs\n\t\trequire(_target != address(0), \"zero address\");\n\n\t\t// initialize internal contract state\n\t\ttarget = _target;\n\t}\n\n\t/**\n\t * @dev Updates the access role required to execute the function defined by its signature\n\t *      on the target contract\n\t *\n\t * @dev More on function signatures and selectors: https://docs.soliditylang.org/en/develop/abi-spec.html\n\t *\n\t * @param signature function signature on the target contract, for example\n\t *      \"transferOwnership(address)\"\n\t * @param role role required to execute this function, or zero to disable\n\t *      access to the specified function for everyone\n\t */\n\tfunction updateAccessRole(string memory signature, uint256 role) public {\n\t\t// delegate to `updateAccessRole(bytes4, uint256)`\n\t\tupdateAccessRole(bytes4(keccak256(bytes(signature))), role);\n\t}\n\n\t/**\n\t * @dev Updates the access role required to execute the function defined by its selector\n\t *      on the target contract\n\t *\n\t * @dev More on function signatures and selectors: https://docs.soliditylang.org/en/develop/abi-spec.html\n\t *\n\t * @param selector function selector on the target contract, for example\n\t *      0xf2fde38b selector corresponds to the \"transferOwnership(address)\" function\n\t * @param role role required to execute this function, or zero to disable\n\t *      access to the specified function for everyone\n\t */\n\tfunction updateAccessRole(bytes4 selector, uint256 role) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_ACCESS_ROLES_MANAGER), \"access denied\");\n\n\t\t// update the function access role\n\t\taccessRoles[selector] = role;\n\n\t\t// emit an event\n\t\temit AccessRoleUpdated(selector, role);\n\t}\n\n\t/**\n\t * @dev Low-level execute of the data calldata on the target contract\n\t *\n\t * @dev This function extracts the target function selector from the calldata specified\n\t *      and verifies transaction executor permission to access the function on the target\n\t *      using the `accessRoles` mapping\n\t *\n\t * @dev Throws if there is no `accessRoles` mapping configured for the function\n\t * @dev Throws if transaction executor role doesn't contain the required role from `accessRoles` mapping\n\t * @dev Throws if execution on the target returns an error\n\t *\n\t * @param data low-level calldata to be passed as is to the target contract for the execution\n\t * @return the response from the target contract after the successful execution\n\t */\n\tfunction execute(bytes memory data) public payable returns(bytes memory) {\n\t\t// extract the selector (first 4 bytes as bytes4) using assembly\n\t\tbytes4 selector;\n\t\tassembly {\n\t\t\t// load the first word after the length field\n\t\t\tselector := mload(add(data, 32))\n\t\t}\n\n\t\t// zero data length means we're trying to execute the receive() function on\n\t\t// the target and supply some ether to the target; in this case we don't need a security check\n\t\t// if the data is present, we're executing some real function and must do a security check\n\t\tif(data.length != 0) {\n\t\t\t// determine the role required to access the function\n\t\t\tuint256 roleRequired = accessRoles[selector];\n\n\t\t\t// verify function access role was already set\n\t\t\trequire(roleRequired != 0, \"access role not set\");\n\n\t\t\t// verify the access permission\n\t\t\trequire(isSenderInRole(roleRequired), \"access denied\");\n\t\t}\n\n\t\t// execute the call on the target\n\t\t(bool success, bytes memory result) = address(target).call{value: msg.value}(data);\n\n\t\t// verify the execution completed successfully\n\t\trequire(success, \"execution failed\");\n\n\t\t// emit an event\n\t\temit ExecutionComplete(selector, data, result);\n\n\t\t// return the result\n\t\treturn result;\n\t}\n\n\t/**\n\t * @dev Proxies the ether sent to the AccessControl Adapter to the target contract\n\t *\n\t * @dev Throws if target contract doesn't have the default payable receiver, i.e. doesn't accept ether\n\t */\n\treceive() external payable {\n\t\t// delegate to `execute(bytes)`\n\t\texecute(bytes(\"\"));\n\t}\n\n\t/**\n\t * @dev Calls the target contract with the calldata specified in the transaction\n\t *\n\t * @dev See `execute()` function for details\n\t * @dev Use `execute()` function directly if the target contract function signature collides\n\t *      with any of the AccessControl Adapter functions signature\n\t */\n\tfallback() external payable {\n\t\t// msg.data contains full calldata: function selector + encoded function arguments (if any)\n\t\t// delegate to `execute(bytes)`\n\t\texecute(msg.data);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}